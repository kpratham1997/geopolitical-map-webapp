Interactive Geopolitical Map Web Application
This Flask-based web application allows users to explore a world map, select countries by clicking on them, and view their geopolitical allies and enemies. It also features a "zoom to rectangle" functionality, enabling users to define a specific area on the map to zoom into, and a "Reset View" button to return to the global perspective.

The application dynamically generates map images on the server-side using matplotlib and cartopy based on user interactions, and shapely is used for precise geographical point-in-polygon detection.

Features
Click to Select Country: Click on any country on the map to display its name, allies, and enemies in the information panel.

Dynamic Coloring: When a country is selected:

The selected country turns orange.

Its allies turn green.

Its enemies turn red.

Drag to Zoom: Click and drag to draw a rectangle on the map. Releasing the mouse will zoom the map to the area defined by your rectangle.

Click on Ocean: Clicking on the ocean or an unmapped area will clear the country information and revert the map colors to default (grey) while maintaining the current zoom level.

Reset View: A dedicated button to instantly revert the map to its default global (unzoomed) view.

Loading Indicator: A visual spinner indicates when the map is being regenerated by the server.

Technologies Used
Backend: Python (Flask)

Flask: Web framework.

Matplotlib: For plotting and image generation.

Cartopy: Geospatial data visualization library, used for drawing maps and country boundaries.

Shapely: For geometric operations, used to determine which country was clicked based on coordinates.

Numpy: Numerical operations for coordinate transformations.

Frontend: HTML, CSS (Tailwind CSS via CDN), JavaScript (Fetch API)

Setup and Running Locally
Follow these steps to get the application running on your local machine:

1. Clone the Repository
First, clone this GitHub repository to your local machine:

git clone https://github.com/kpratham1997/geopolitical-map-webapp.git
cd geopolitical-map-webapp

2. Create a Python Virtual Environment
It's highly recommended to use a virtual environment to manage project dependencies.

python3 -m venv venv

3. Activate the Virtual Environment
On macOS/Linux:

source venv/bin/activate

On Windows (Command Prompt):

venv\Scripts\activate.bat

On Windows (PowerShell):

.\venv\Scripts\Activate.ps1

4. Install Dependencies
With your virtual environment activated, install all necessary Python packages:

pip install -r requirements.txt

If requirements.txt is missing or outdated, you can create it with:

pip freeze > requirements.txt

5. Generate Initial Map (Automatic)
The application is set up to automatically generate the initial world_map_default.png file in the static/ directory when the Flask server starts for the first time or if the file is missing. Ensure the static folder exists.

6. Run the Flask Application
Once all dependencies are installed, you can start the Flask development server:

python3 app.py

You should see output similar to this:

 * Serving Flask app 'app'
 * Debug mode: on
WARNING: This is a development server. Do not use it in a production deployment.
Use a production WSGI server instead.
 * Running on http://127.0.0.1:5000
Press CTRL+C to quit
Country geometries loaded successfully.
Clearing contents of /path/to/your/geopolitical-map-webapp/static/ on app startup...
Static folder cleanup complete.
Generated initial default map at /path/to/your/geopolitical-map-webapp/static/world_map_default.png

7. Access the Web Application
Open your web browser and navigate to:

http://127.0.0.1:5000/

You should now see the interactive world map!

Important Notes on Deployment
Dynamic Image Generation: This application generates map images on the server for every interaction (click, zoom). While functional for demonstration, this approach can be resource-intensive and slow on free hosting tiers. For a production-grade, highly interactive map, a client-side JavaScript mapping library (e.g., Leaflet, OpenLayers, Mapbox GL JS) would typically be used.

app.secret_key: In app.py, app.secret_key is set with a placeholder value. For any production deployment, you MUST change this to a long, random, and securely stored value (e.g., via environment variables).

Procfile and requirements.txt: These files are included for easy deployment to platforms like Heroku or Render that use them to detect and run Python web applications.

Static Folder Cleanup: The static/ folder is cleared at app startup to ensure a clean slate. In a production environment, you might want a more sophisticated caching or storage strategy (e.g., cloud storage for images) rather than relying on dynamic file system writes.

Enjoy exploring the geopolitical map!
